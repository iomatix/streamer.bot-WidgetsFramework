const sbServerAddress = "127.0.0.1";
const sbServerPort = "8080";

// Options: "classic" or "stacked"
// Stacked mode shows multiple alerts at once, classic mode shows one alert at a time
const ALERT_MODE = "stacked";
const ALERT_DIRECTION = "left-right";  // "bottom-up", "top-down", "left-right", "right-left"
const ALERT_ANIMATION = "scale"; // "slide-fade", "fade", "scale"


const ENABLE_TWITCH = true;
const ENABLE_YOUTUBE = false;
const ENABLE_KICK = false;
const ENABLE_TIKTOK = false;
const ENABLE_KOFI = true;
const ENABLE_TIPPEEESTREAM = false;
const ENABLE_STREAMELEMENTS = true;
const ENABLE_STREAMLABS = false;
const ENABLE_PATREON = false;
const ENABLE_FOURTHWALL = false;

const EVENT_BUFFER_LIMIT = 16;
let alertQueue = [];
let eventBuffer = [];

/* === URL PARAMS / FILTERING CONFIG === */
// index: fixed single event index (0 = newest)
// platform: filter by platform (twitch, youtube, kick, etc.)
// type: filter by event type (sub, follow, donation, raid, etc.)
// list: render N latest events instead of a single alert

function getParam(name) {
	const url = new URL(window.location.href);
	return url.searchParams.get(name);
}

const PARAM_INDEX = getParam("index") !== null ? parseInt(getParam("index"), 10) : null;
const PARAM_PLATFORM = getParam("platform"); // e.g. "twitch"
const PARAM_TYPE = getParam("type");         // e.g. "sub", "follow", "donation"
const PARAM_LIST = getParam("list") !== null ? parseInt(getParam("list"), 10) : null;

/* === EVENT BUFFER HELPERS === */

function pushToEventBuffer(alert) {
	// You can extend this later with more metadata if needed
	eventBuffer.unshift(alert);
	if (eventBuffer.length > EVENT_BUFFER_LIMIT) {
		eventBuffer.pop();
	}
}

function getFilteredEvents() {
	return eventBuffer.filter(ev => {
		if (PARAM_PLATFORM && ev.platform !== PARAM_PLATFORM) return false;
		if (PARAM_TYPE && ev.type && ev.type !== PARAM_TYPE) return false;
		return true;
	});
}

/////////////////////////
// STREAMER.BOT CLIENT //
/////////////////////////

const client = new StreamerbotClient({
	host: sbServerAddress,
	port: sbServerPort,

	onConnect: (data) => {
		console.log(`Streamer.bot successfully connected to ${sbServerAddress}:${sbServerPort}`)
		console.debug(data);
		SetConnectionStatus(true);
	},

	onDisconnect: () => {
		console.error(`Streamer.bot disconnected from ${sbServerAddress}:${sbServerPort}`)
		SetConnectionStatus(false);
	}
});

client.on('Twitch.Follow', (response) => {
	console.debug(response.data);
	TwitchFollow(response.data);
})

client.on('Twitch.Cheer', (response) => {
	console.debug(response.data);
	TwitchCheer(response.data);
})

client.on('Twitch.Sub', (response) => {
	console.debug(response.data);
	TwitchSub(response.data);
})

client.on('Twitch.ReSub', (response) => {
	console.debug(response.data);
	TwitchResub(response.data);
})

client.on('Twitch.GiftSub', (response) => {
	console.debug(response.data);
	TwitchGiftSub(response.data);
})

client.on('Twitch.GiftBomb', (response) => {
	console.debug(response.data);
	TwitchGiftBomb(response.data);
})

client.on('Twitch.RewardRedemption', (response) => {
	console.debug(response.data);
	TwitchRewardRedemption(response.data);
})

client.on('Twitch.Raid', (response) => {
	console.debug(response.data);
	TwitchRaid(response.data);
})

client.on('Twitch.WatchStreak', (response) => {
	console.debug(response.data);
	TwitchWatchStreak(response.data);
})

client.on('YouTube.SuperChat', (response) => {
	console.debug(response.data);
	YouTubeSuperChat(response.data);
})

client.on('YouTube.SuperSticker', (response) => {
	console.debug(response.data);
	YouTubeSuperSticker(response.data);
})

client.on('YouTube.NewSponsor', (response) => {
	console.debug(response.data);
	YouTubeNewSponsor(response.data);
})

client.on('YouTube.GiftMembershipReceived', (response) => {
	console.debug(response.data);
	YouTubeGiftMembershipReceived(response.data);
})

client.on('Streamlabs.Donation', (response) => {
	console.debug(response.data);
	StreamlabsDonation(response.data);
})

client.on('StreamElements.Tip', (response) => {
	console.debug(response.data);
	StreamElementsTip(response.data);
})

client.on('Patreon.PledgeCreated', (response) => {
	console.debug(response.data);
	PatreonPledgeCreated(response.data);
})

client.on('Kofi.Donation', (response) => {
	console.debug(response.data);
	KofiDonation(response.data);
})

client.on('Kofi.Subscription', (response) => {
	console.debug(response.data);
	KofiSubscription(response.data);
})

client.on('Kofi.Resubscription', (response) => {
	console.debug(response.data);
	KofiResubscription(response.data);
})

client.on('Kofi.ShopOrder', (response) => {
	console.debug(response.data);
	KofiShopOrder(response.data);
})

client.on('TipeeeStream.Donation', (response) => {
	console.debug(response.data);
	TipeeeStreamDonation(response.data);
})

client.on('Fourthwall.OrderPlaced', (response) => {
	console.debug(response.data);
	FourthwallOrderPlaced(response.data);
})

client.on('Fourthwall.Donation', (response) => {
	console.debug(response.data);
	FourthwallDonation(response.data);
})

client.on('Fourthwall.SubscriptionPurchased', (response) => {
	console.debug(response.data);
	FourthwallSubscriptionPurchased(response.data);
})

client.on('Fourthwall.GiftPurchase', (response) => {
	console.debug(response.data);
	FourthwallGiftPurchase(response.data);
})

client.on('Fourthwall.GiftDrawStarted', (response) => {
	console.debug(response.data);
	FourthwallGiftDrawStarted(response.data);
})

client.on('Fourthwall.GiftDrawEnded', (response) => {
	console.debug(response.data);
	FourthwallGiftDrawEnded(response.data);
})

//////////////////////
// TIKFINITY CLIENT //
//////////////////////

let tikfinityWebsocket = null;

function TikfinityConnect() {
	if (!ENABLE_TIKTOK)
		return;

	if (tikfinityWebsocket) return; // Already connected

	tikfinityWebsocket = new WebSocket("ws://localhost:21213/");

	tikfinityWebsocket.onopen = function () {
		console.log(`TikFinity successfully connected...`)
	}

	tikfinityWebsocket.onclose = function () {
		console.error(`TikFinity disconnected...`)
		tikfinityWebsocket = null;
		setTimeout(TikfinityConnect, 1000); // Schedule a reconnect attempt
	}

	tikfinityWebsocket.onerror = function () {
		console.error(`TikFinity failed for some reason...`)
		tikfinityWebsocket = null;
		setTimeout(TikfinityConnect, 1000); // Schedule a reconnect attempt
	}

	tikfinityWebsocket.onmessage = function (response) {
		let payload = JSON.parse(response.data);

		let event = payload.event;
		let data = payload.data;

		console.debug('Event: ' + event);

		switch (event) {
			case 'gift':
				TikTokGift(data);
				break;
			case 'subscribe':
				TikTokSubscribe(data);
				break;
		}
	}
}

// Try connect when window is loaded
window.addEventListener('load', TikfinityConnect);



///////////////////////
// MULTICHAT OVERLAY //
///////////////////////

async function TwitchFollow(data) {
	if (!ENABLE_TWITCH) return;

	// Set the text
	const username = data.user_name;

	// Render avatars
	const avatarURL = await GetAvatar(username, 'twitch');

	UpdateAlertBox(
		'twitch',
		avatarURL,
		`${username}`,
		`followed`,
		``,
		username,
		``,
		'follow',
		data,
		'follow'
	);
}

async function TwitchCheer(data) {
	if (!ENABLE_TWITCH) return;

	// Set the text
	const username = data.message.displayName;
	const bits = data.bits;
	let message = data.message.message;

	// Render avatars
	const avatarURL = await GetAvatar(username, 'twitch');

	// Render emotes
	for (i in data.emotes) {
		const emoteElement = `<img src="${data.emotes[i].imageUrl}" class="emote"/>`;
		const emoteName = EscapeRegExp(data.emotes[i].name);

		let regexPattern = emoteName;

		// Check if the emote name consists only of word characters (alphanumeric and underscore)
		if (/^\w+$/.test(emoteName)) {
			regexPattern = `\\b${emoteName}\\b`;
		}
		else {
			// For non-word emotes, ensure they are surrounded by non-word characters or boundaries
			regexPattern = `(?:^|[^\\w])${emoteName}(?:$|[^\\w])`;
		}

		const regex = new RegExp(regexPattern, 'g');
		message = message.replace(regex, emoteElement);
	}

	// Render cheermotes
	for (i in data.cheerEmotes) {
		const bits = data.cheerEmotes[i].bits;
		const imageUrl = data.cheerEmotes[i].imageUrl;
		const name = data.cheerEmotes[i].name;
		const cheerEmoteElement = `<img src="${imageUrl}" class="emote"/>`;
		const bitsElements = `<span class="bits">${bits}</span>`
		message = message.replace(new RegExp(`\\b${name}${bits}\\b`, 'i'), cheerEmoteElement + bitsElements);
	}

	UpdateAlertBox(
		'twitch',
		avatarURL,
		`${username}`,
		`cheered ${bits} bits`,
		'',
		username,
		message,
		'cheer',
		data
	);
}

async function TwitchSub(data) {
	if (!ENABLE_TWITCH) return;

	// Set the text
	const username = data.user.name;
	const subTier = data.sub_tier;
	const isPrime = data.is_prime;

	// Render avatars
	const avatarURL = await GetAvatar(username, 'twitch');

	if (!isPrime)
		UpdateAlertBox(
			'twitch',
			avatarURL,
			`${username}`,
			`subscribed with Tier ${subTier.charAt(0)}`,
			'',
			username,
			'',
			'sub',
			data,
			'sub'
		);
	else
		UpdateAlertBox(
			'twitch',
			avatarURL,
			`${username}`,
			`used their Prime Sub`,
			'',
			username,
			'',
			'sub',
			data
		);
}

async function TwitchResub(data) {
	if (!ENABLE_TWITCH) return;

	// Set the text
	const username = data.user.name;
	const subTier = data.subTier;
	const isPrime = data.isPrime;
	const cumulativeMonths = data.cumulativeMonths;
	const message = data.text;

	// Render avatars
	const avatarURL = await GetAvatar(username, 'twitch');

	if (!isPrime)
		UpdateAlertBox(
			'twitch',
			avatarURL,
			`${username}`,
			`resubscribed with Tier ${subTier.charAt(0)}`,
			`${cumulativeMonths} months`,
			username,
			message,
			'resub',
			data,
			'resub'
		);
	else
		UpdateAlertBox(
			'twitch',
			avatarURL,
			`${username}`,
			`used their Prime Sub`,
			`${cumulativeMonths} months`,
			username,
			message,
			'resub',
			data,
			'resub'
		);
}

async function TwitchGiftSub(data) {
	if (!ENABLE_TWITCH) return;

	// Set the text
	const username = data.user.name;
	const subTier = data.subTier;
	const recipient = data.recipient.name;
	const cumlativeTotal = data.cumlativeTotal;
	const fromCommunitySubGift = data.fromCommunitySubGift;

	// Don't post alerts for gift bombs
	if (fromCommunitySubGift)
		return;

	// Render avatars
	const avatarURL = await GetAvatar(username, 'twitch');

	let messageText = '';
	if (cumlativeTotal > 0)
		messageText = `They've gifted ${cumlativeTotal} subs in total!`;

	UpdateAlertBox(
		'twitch',
		avatarURL,
		`${username}`,
		`gifted a Tier ${subTier.charAt(0)} subscription`,
		`to ${recipient}`,
		username,
		messageText,
		'giftsub',
		data,
		'giftsub'
	);
}

async function TwitchGiftBomb(data) {
	if (!ENABLE_TWITCH) return;

	//// The below is incorrect (Streamer.bot documentation is wrong)
	// const username = data.displayName;
	// const gifts = data.gifts;
	// const totalGifts = data.totalGifts;
	// const subTier = data.subTier;
	const username = data.user.name;
	const login = data.user.login;
	const gifts = data.recipients.length;
	const totalGifts = data.cumulative_total;
	const subTier = data.sub_tier.charAt(0);

	// Render avatars
	const avatarURL = await GetAvatar(login, 'twitch');

	let message = ``;
	if (totalGifts > 0)
		message = `They've gifted ${totalGifts} subs in total!`;

	UpdateAlertBox(
		'twitch',
		avatarURL,
		`${username}`,
		`gifted ${gifts} Tier ${subTier} subs!`,
		``,
		username,
		message,
		'giftsub',
		data,
		'giftsub'
	);
}

async function TwitchRewardRedemption(data) {
	if (!ENABLE_TWITCH) return;

	const username = data.user_name;
	const rewardName = data.reward.title;
	const cost = data.reward.cost;
	const userInput = data.user_input;
	const channelPointIcon = `<img src="icons/badges/twitch-channel-point.png" class="platform" style="height: 1em"/>`;

	// Render avatars
	const avatarURL = await GetAvatar(data.user_login, 'twitch');

	UpdateAlertBox(
		'twitch',
		avatarURL,
		`${username} redeemed`,
		`${rewardName} ${channelPointIcon} ${cost}`,
		'',
		username,
		userInput,
		'reward',
		data,
		'reward'
	);
}

async function TwitchRaid(data) {
	if (!ENABLE_TWITCH) return;

	// Render avatars
	const avatarURL = await GetAvatar(data.from_broadcaster_user_login, 'twitch');

	// Set the text
	const username = data.from_broadcaster_user_login;
	const viewers = data.viewers;

	UpdateAlertBox(
		'twitch',
		avatarURL,
		`${username}`,
		`is raiding with a party of ${viewers}`,
		'',
		username,
		'',
		'raid',
		data,
		'raid'
	);
}

async function TwitchWatchStreak(data) {
	if (!ENABLE_TWITCH) return;

	// Render avatars
	const avatarURL = await GetAvatar(data.userName, 'twitch');

	// Set the text
	const username = data.displayName;
	const watchStreak = data.watchStreak;

	UpdateAlertBox(
		'twitch',
		avatarURL,
		`${username}`,
		`is currently on a ${watchStreak} stream streak!`,
		'',
		username,
		'',
		'watchstreak',
		data
	);
}

function YouTubeSuperChat(data) {
	if (!ENABLE_YOUTUBE) return;

	// Render avatars
	const avatarURL = data.user.profileImageUrl;

	UpdateAlertBox(
		'youtube',
		avatarURL,
		`${data.user.name}`,
		`sent a Super Chat (${data.amount})`,
		'',
		data.user.name,
		data.message,
		'superchat',
		data
	);
}

function YouTubeSuperSticker(data) {
	if (!ENABLE_YOUTUBE) return;

	// Render avatars
	const avatarURL = FindFirstImageUrl(data);

	UpdateAlertBox(
		'youtube',
		avatarURL,
		`${data.user.name}`,
		`sent a Super Sticker (${data.amount})`,
		'',
		data.user.name,
		'',
		'supersticker',
		data,
		'supersticker'
	);
}

function YouTubeNewSponsor(data) {
	if (!ENABLE_YOUTUBE) return;

	// Render avatars
	const avatarURL = data.user.profileImageUrl;

	UpdateAlertBox(
		'youtube',
		avatarURL,
		`‚≠ê New ${data.levelName}`,
		`Welcome ${data.user.name}!`,
		'',
		data.user.name,
		'',
		'sponsorsub',
		data,
		'sponsorsub'
	);
}

function YouTubeGiftMembershipReceived(data) {
	if (!ENABLE_YOUTUBE) return;

	// Render avatars
	const avatarURL = data.user.profileImageUrl;

	UpdateAlertBox(
		'youtube',
		avatarURL,
		`${data.gifter.name}`,
		`gifted a membership`,
		`to ${data.user.name} (${data.tier})!`,
		data.gifter.name,
		'',
		'sponsorsub',
		data,
		'sponsorsub'
	);
}

async function StreamlabsDonation(data) {
	if (!ENABLE_STREAMLABS) return;

	// Set the text
	const donater = data.from;
	const formattedAmount = data.formattedAmount;
	const currency = data.currency;
	const message = data.message;

	UpdateAlertBox(
		'streamlabs',
		'',
		`${donater}`,
		`donated ${currency}${formattedAmount}`,
		``,
		donater,
		message,
		'donation',
		data,
		'donation'
	);
}

async function StreamElementsTip(data) {
	if (!ENABLE_STREAMELEMENTS) return;

	// Set the text
	const donater = data.username;
	const formattedAmount = `$${data.amount}`;
	const currency = data.currency;
	const message = data.message;

	UpdateAlertBox(
		'streamelements',
		'',
		`${donater}`,
		`donated ${currency}${formattedAmount}`,
		``,
		donater,
		message,
		'donation',
		data,
		'donation'
	);
}

function PatreonPledgeCreated(data) {
	if (!ENABLE_PATREON) return;

	const user = data.attributes.full_name;
	const amount = (data.attributes.will_pay_amount_cents / 100).toFixed(2);
	const patreonIcon = `<img src="icons/platforms/patreon.png" class="platform"/>`;

	// Render avatars
	const avatarURL = 'icons/platforms/patreon.png';

	UpdateAlertBox(
		'patreon',
		avatarURL,
		`${user}`,
		`joined Patreon ($${amount})`,
		``,
		user,
		``,
		'sub',
		data,
		'sub'
	);
}

function KofiDonation(data) {
	if (!ENABLE_KOFI) return;

	// Set the text
	const user = data.from;
	const amount = data.amount;
	const currency = data.currency;
	const message = data.message;

	// Render avatars
	const avatarURL = 'icons/platforms/kofi.png';

	if (currency == "USD")
		UpdateAlertBox(
			'kofi',
			avatarURL,
			`${user}`,
			`donated $${amount}`,
			``,
			user,
			message,
			'donation',
			data,
			'donation'
		);
	else
		UpdateAlertBox(
			'kofi',
			avatarURL,
			`${user}`,
			`donated ${currency} ${amount}`,
			``,
			user,
			message,
			'donation',
			data
		);
}

function KofiSubscription(data) {
	if (!ENABLE_KOFI) return;

	// Set the text
	const user = data.from;
	const amount = data.amount;
	const currency = data.currency;
	const message = data.message;

	// Render avatars
	const avatarURL = 'icons/platforms/kofi.png';

	if (currency == "USD")
		UpdateAlertBox(
			'kofi',
			avatarURL,
			`${user}`,
			`subscribed ($${amount})`,
			``,
			user,
			message,
			'sub',
			data,
			'sub'
		);
	else
		UpdateAlertBox(
			'kofi',
			`${user}`,
			`subscribed (${currency} ${amount})`,
			``,
			user,
			message,
			'sub',
			data
		);
}

function KofiResubscription(data) {
	if (!ENABLE_KOFI) return;

	// Set the text
	const user = data.from;
	const tier = data.tier;
	const message = data.message;

	// Render avatars
	const avatarURL = 'icons/platforms/kofi.png';

	UpdateAlertBox(
		'kofi',
		avatarURL,
		`${user}`,
		`subscribed (${tier})`,
		``,
		user,
		message,
		'sub',
		data,
		'sub'
	);
}

function KofiShopOrder(data) {
	if (!ENABLE_KOFI) return;

	// Set the text
	const user = data.from;
	const amount = data.amount;
	const currency = data.currency;
	const message = data.message;
	const itemTotal = data.items.length;
	let formattedAmount = "";

	if (amount == 0)
		formattedAmount = ""
	else if (currency == "USD")
		formattedAmount = `$${amount}`;
	else
		formattedAmount = `${currency} ${amount}`;

	// Render avatars
	const avatarURL = 'icons/platforms/kofi.png';

	UpdateAlertBox(
		'kofi',
		avatarURL,
		`${user}`,
		`ordered ${itemTotal} item(s) on Ko-fi `,
		`${formattedAmount}`,
		user,
		message,
		'shoporder',
		data,
		'shoporder'
	);
}

function TipeeeStreamDonation(data) {
	if (!ENABLE_TIPPEEESTREAM) return;

	// Set the text
	const user = data.username;
	const amount = data.amount;
	const currency = data.currency;
	const message = data.message;

	// Render avatars
	const avatarURL = 'icons/platforms/tipeeeStream.png';

	if (currency == "USD")
		UpdateAlertBox(
			'tipeeeStream',
			avatarURL,
			`${user}`,
			`donated $${amount}`,
			``,
			user,
			message,
			'donation',
			data,
			'donation'
		);
	else
		UpdateAlertBox(
			'tipeeeStream',
			avatarURL,
			`${user}`,
			`donated ${currency} ${amount}`,
			``,
			user,
			message,
			'donation',
			data,
			'donation'
		);
}

function FourthwallOrderPlaced(data) {
	if (!ENABLE_FOURTHWALL) return;

	// Set the text
	let user = data.username;
	const orderTotal = data.total;
	const currency = data.currency;
	const item = data.variants[0].name;
	const itemsOrdered = data.variants.length;
	const message = DecodeHTMLString(data.statmessageus);
	const itemImageUrl = data.variants[0].image;

	// If there user did not provide a username, just say "Someone"
	if (user == undefined)
		user = "Someone";

	let attributeText = ""

	// If the user ordered more than one item, write how many items they ordered
	if (itemsOrdered > 1)
		attributeText += `and ${itemsOrdered - 1} other item(s)!`;

	// If the user spent money, put the order total
	if (orderTotal == 0)
		attributeText += ``;
	else if (currency == "USD")
		attributeText += ` ($${orderTotal})`;
	else
		attributeText += ` (${orderTotal} ${currency})`;

	UpdateAlertBox(
		'fourthwall',
		itemImageUrl,
		`${user}`,
		`ordered ${item}`,
		attributeText,
		user,
		message,
		'shoporder',
		data,
		'shoporder'
	);
}

function FourthwallDonation(data) {
	if (!ENABLE_FOURTHWALL) return;

	// Set the text
	let user = data.username;
	const amount = data.amount;
	const currency = data.currency;
	const message = data.message;

	let formattedAmount = '';

	// If the user spent money, put the order total
	if (currency == "USD")
		formattedAmount += ` $${amount}`;
	else
		formattedAmount += ` ${currency} ${amount}`;

	UpdateAlertBox(
		'fourthwall',
		'',
		`${user}`,
		`donated ${formattedAmount}`,
		'',
		user,
		message,
		'donation',
		data,
		'donation'
	);
}

function FourthwallSubscriptionPurchased(data) {
	if (!ENABLE_FOURTHWALL) return;

	// Set the text
	let user = data.nickname;
	const amount = data.amount;
	const currency = data.currency;

	let formattedAmount = '';

	// If the user spent money, put the order total
	if (currency == "USD")
		formattedAmount += ` ($${amount})`;
	else
		formattedAmount += ` (${currency} ${amount})`;

	UpdateAlertBox(
		'fourthwall',
		'',
		`${user}`,
		`subscribed ${formattedAmount}`,
		'',
		user,
		'',
		'sub',
		data,
		'sub'
	);
}

function FourthwallGiftPurchase(data) {
	if (!ENABLE_FOURTHWALL) return;

	// Set the text
	// let user = data.username;
	const total = data.total;
	const currency = data.currency;
	const gifts = data.gifts.length;
	const itemName = data.offer.name;
	const itemImageUrl = data.offer.imageUrl;
	// const message = DecodeHTMLString(data.statmessageus);

	let contents = '';
	let attributesText = '';

	// If there is more than one gifted item, display the number of gifts
	if (gifts > 1)
		contents += ` ${gifts} x `;

	// The name of the item to be given away
	contents += ` ${itemName}`;

	// If the user spent money, put the order total
	if (currency == "USD")
		attributesText = `$${total}`;
	else
		attributesText = `${currency}${total}`;

	UpdateAlertBox(
		'fourthwall',
		itemImageUrl,
		`An item has been gifted!`,// `${user}`,
		`${contents}`, // `gifted ${contents}`,
		attributesText,
		'', // user,
		'', // message,
		'gift',
		data,
		'gift'
	);
}

function FourthwallGiftDrawStarted(data) {
	if (!ENABLE_FOURTHWALL) return;

	// Set the text
	const durationSeconds = data.durationSeconds;
	const itemName = data.offer.name;

	UpdateAlertBox(
		'fourthwall',
		'',
		`<span style="font-size: 1.2em">üéÅ ${itemName} Giveaway!</span>`,
		`Type 'join' in the next ${durationSeconds} seconds for your chance to win!`,
		'',
		'',
		'',
		'gift',
		data,
		'gift'
	);
}

function FourthwallGiftDrawEnded(data) {
	if (!ENABLE_FOURTHWALL) return;

	UpdateAlertBox(
		'fourthwall',
		'',
		`<span style="font-size: 1.2em">ü•≥ GIVEAWAY ENDED ü•≥</span>`,
		`Congratulations ${GetWinnersList(data.gifts)}!`,
		'',
		'',
		'',
		'gift',
		data
	);
}

// async function KickFollow(data) {
// 	if (!showKickFollows)
// 		return;

// 	// Set the text
// 	const username = data.user;

// 	// Render avatars
// 	const avatarURL = await GetAvatar(username, 'kick');

// 	UpdateAlertBox(
// 		'kick',
// 		avatarURL,
// 		`${username}`,
// 		`followed`,
// 		'',
// 		username,
// 		'',
// 		kickFollowAction,
// 		data
// 	);
// }

async function KickSubscription(data) {
	if (!ENABLE_KICK) return;

	// Set the text
	const username = data.username;
	const months = data.months;

	let description = '';
	if (months <= 1)
		description = `just subscribed for the first time!`;
	else
		description = `resubscribed!`;

	const attribute = `${months} months`;

	// Render avatars
	const avatarURL = await GetAvatar(username, 'kick');

	UpdateAlertBox(
		'kick',
		avatarURL,
		`${username}`,
		description,
		attribute,
		username,
		'',
		'sub',
		data,
		'sub'
	);
}

async function KickGiftedSubscriptions(data) {
	if (!ENABLE_KICK) return;

	// Set the text
	const gifter = data.gifter_username;
	const giftedUsers = data.gifted_usernames;

	let description = '';
	let attribute = '';

	if (giftedUsers.length <= 1) {
		description = `gifted a sub to`;
		attribute = `${giftedUsers[0]}`;
	}
	else
		description = `gifted ${giftedUsers.length} subscription${giftedUsers.length === 1 ? '' : 's'} to the community!`;

	// Render avatars
	const avatarURL = await GetAvatar(gifter, 'kick');

	UpdateAlertBox(
		'kick',
		avatarURL,
		`${gifter}`,
		description,
		attribute,
		gifter,
		'',
		'sub',
		data,
		'sub'
	);
}

async function KickRewardRedeemed(data) {
	if (!ENABLE_KICK) return;

	const username = data.username;
	const rewardName = data.reward_title;
	const userInput = data.user_input;

	// Render avatars
	const avatarURL = await GetAvatar(username, 'kick');

	UpdateAlertBox(
		'kick',
		avatarURL,
		`${username} redeemed`,
		`${rewardName}`,
		'',
		username,
		userInput,
		'reward',
		data,
		'reward'
	);
}

async function KickStreamHost(data) {
	if (!ENABLE_KICK) return;

	// Render avatars
	const avatarURL = await GetAvatar(data.host_username, 'kick');

	// Set the text
	const username = data.host_username;
	const viewers = data.number_viewers;

	UpdateAlertBox(
		'kick',
		avatarURL,
		`${username}`,
		`is raiding with a party of ${viewers}`,
		'',
		username,
		'',
		'raid',
		data,
		'raid'
	);
}

async function KickKicksGifted(data) {
	if (!ENABLE_KICK) return;

	// Set the text
	const username = data.sender.username;
	const tiktokIcon = `<img src="icons/platforms/kick.png" class="platform"/>`;
	// const giftImg = `<img src=https://files.kick.com/kicks/gifts/${data.gift.gift_id.replace('_', '-')}.webp style="height: 1em"/>`;
	const kickKicksIcon = `<img src=icons/badges/kick-kicks.svg style="height: 0.8em"/>`;

	// Render avatars
	const avatarURL = `https://files.kick.com/kicks/gifts/${data.gift.gift_id.replace('_', '-')}.webp`;

	UpdateAlertBox(
		'kick',
		avatarURL,
		`${username}`,
		`sent ${kickKicksIcon} ${data.gift.amount}`,
		'',
		username,
		data.message,
		'kicks',
		data
	);
}

async function TikTokGift(data) {
	if (!ENABLE_TIKTOK) return;

	if (data.giftType === 1 && !data.repeatEnd) {
		// Streak in progress => show only temporary
		console.debug(`${data.uniqueId} is sending gift ${data.giftName} x${data.repeatCount}`);
		return;
	}

	// Streak ended or non-streakable gift => process the gift with final repeat_count
	console.debug(`${data.uniqueId} has sent gift ${data.giftName} x${data.repeatCount}`);

	// Set the text
	const username = data.nickname;
	const tiktokIcon = `<img src="icons/platforms/tiktok.png" class="platform"/>`;
	const giftImg = `<img src=${data.giftPictureUrl} style="height: 1em"/>`;

	// Render avatars
	const avatarURL = 'icons/platforms/tiktok.png';

	UpdateAlertBox(
		'tiktok',
		avatarURL,
		`${username}`,
		`sent ${giftImg}x${data.repeatCount}`,
		'',
		username,
		'',
		'gift',
		data
	);
}

async function TikTokSubscribe(data) {
	if (!ENABLE_TIKTOK) return;

	// Set the text
	const username = data.nickname;
	const tiktokIcon = `<img src="icons/platforms/tiktok.png" class="platform"/>`;

	// Render avatars
	const avatarURL = 'icons/platforms/tiktok.png';

	UpdateAlertBox(
		'tiktok',
		avatarURL,
		`${username}`,
		`subscribed on TikTok`,
		'',
		username,
		'',
		'sub',
		data,
		'sub'
	);
}



//////////////////////
// HELPER FUNCTIONS //
//////////////////////

// I used Gemini for this shit so if it doesn't work, blame Google
function FindFirstImageUrl(jsonObject) {
	if (typeof jsonObject !== 'object' || jsonObject === null) {
		return null; // Handle invalid input
	}

	function iterate(obj) {
		if (Array.isArray(obj)) {
			for (const item of obj) {
				const result = iterate(item);
				if (result) {
					return result;
				}
			}
			return null;
		}

		for (const key in obj) {
			if (obj.hasOwnProperty(key)) {
				if (key === 'imageUrl') {
					return obj[key]; // Found it! Return the value.
				}

				if (typeof obj[key] === 'object' && obj[key] !== null) {
					const result = iterate(obj[key]); // Recursive call for nested objects
					if (result) {
						return result; // Propagate the found value
					}
				}
			}
		}
		return null; // Key not found in this level
	}

	return iterate(jsonObject);
}

function GetWinnersList(gifts) {
	const winners = gifts.map(gift => gift.winner);
	const numWinners = winners.length;

	if (numWinners === 0) {
		return "";
	} else if (numWinners === 1) {
		return winners[0];
	} else if (numWinners === 2) {
		return `${winners[0]} and ${winners[1]}`;
	} else {
		const lastWinner = winners.pop();
		const secondLastWinner = winners.pop();
		return `${winners.join(", ")}, ${secondLastWinner} and ${lastWinner}`;
	}
}

function UpdateAlertBox(platform, avatar, username, description, attribute, userForMessage, message, action, rawData, eventType) {
	// Basic alert object; you can extend this with "type" later
	const alert = {
		platform,
		avatar,
		username,
		description,
		attribute,
		message,
		type: eventType || "alert",
		// type: you can pass this from callers later, for now leave undefined
	};

	// Always push to event buffer for indexed/list widgets
	pushToEventBuffer(alert);

	// If we are in fixed index or list mode, we don't use the normal queue
	if (PARAM_INDEX !== null) {
		renderIndexedEvent();
		return;
	}

	if (PARAM_LIST !== null) {
		renderEventList();
		return;
	}

	// Normal alert mode (classic/stacked)
	alertQueue.push(alert);
	processQueue();
}

let isShowing = false;

function processQueue() {
	if (isShowing) return;
	if (alertQueue.length === 0) return;

	const alert = alertQueue.shift();
	showAlert(alert);
}

function showAlert(alert) {
	if (ALERT_MODE === "classic") {
		showClassicAlert(alert);
	} else {
		showStackedAlert(alert);
	}
}

/* === FIXED INDEX RENDERING === */

function renderIndexedEvent() {
	const container = document.getElementById("alert-container");
	if (!container) return;

	container.innerHTML = "";

	const filtered = getFilteredEvents();
	const idx = Math.max(0, PARAM_INDEX); // safety

	const alert = filtered[idx];
	if (!alert) return;

	const el = buildAlertElement(alert);
	el.classList.add("visible");
	container.appendChild(el);
}

/* === LIST RENDERING (N LATEST EVENTS) === */

function renderEventList() {
	const container = document.getElementById("alert-container");
	if (!container) return;

	container.innerHTML = "";

	const filtered = getFilteredEvents();
	const count = Math.max(1, PARAM_LIST); // at least 1

	filtered.slice(0, count).forEach(alert => {
		const el = buildAlertElement(alert);
		el.classList.add("visible");
		container.appendChild(el);
	});
}

function buildAlertElement(alert) {
	const el = document.createElement("div");
	el.className = `alert ${alert.platform} ${getDirectionClass()} ${getAnimationClass()}`;

	el.innerHTML = `
        <div class="content">
		<img class="avatar hidden" src="${alert.avatar}"
			onload="this.classList.remove('hidden')"
			onerror="if (this && this.parentElement && this.parentElement.parentElement) {
            this.parentElement.parentElement.classList.add('no-avatar');
         }
         this.remove();">
            <div class="text">
                <div class="username">${alert.username}</div>
                <div class="message">
                    ${alert.description} ${alert.attribute ?? ""}
                    <br>
                    ${alert.message ?? ""}
                </div>
            </div>
        </div>
    `;


	return el;
}

function getDirectionClass() {
	switch (ALERT_DIRECTION) {
		case "top-down":
			return "dir-top-down";
		case "left-right":
			return "dir-left-right";
		case "right-left":
			return "dir-right-left";
		default:
			return "dir-bottom-up";
	}
}

function getAnimationClass() {
	switch (ALERT_ANIMATION) {
		case "fade":
			return "anim-fade";
		case "scale":
			return "anim-scale";
		default:
			return "anim-slide-fade";
	}
}


function showClassicAlert(alert) {
	isShowing = true;

	const container = document.getElementById("alert-container");
	container.innerHTML = ""; // czy≈õcimy poprzedni alert

	const el = buildAlertElement(alert);
	container.appendChild(el);

	requestAnimationFrame(() => {
		el.classList.add("visible");
	});

	setTimeout(() => {
		el.classList.remove("visible");
		setTimeout(() => {
			isShowing = false;
			processQueue();
		}, 550);
	}, 5500);
}

function showStackedAlert(alert) {
	const container = document.getElementById("alert-container");

	const el = buildAlertElement(alert);
	el.classList.add("pre-anim");

	container.appendChild(el);

	// 2‚Äëframe delay to guarantee animation
	requestAnimationFrame(() => {
		requestAnimationFrame(() => {
			el.classList.remove("pre-anim");
			el.classList.add("visible");
		});
	});

	setTimeout(() => {
		el.classList.remove("visible");
		setTimeout(() => {
			el.remove();
		}, 550);
	}, 5500);

	processQueue();
}
////////////////////
// TEST FUNCTIONS //
////////////////////

async function testWidget(platform = "twitch", user = "nightshade_zane") {
	UpdateAlertBox(
		platform,
		await GetAvatar(user, platform),
		user,
		`subscribed with Tier 69 !`,
		'',
		`Zane Zane`,
		`Oo to jest pytanie, czy Zane tutaj wstanie?`
		//``
	);
}


///////////////////////////////////
// STREAMER.BOT WEBSOCKET STATUS //
///////////////////////////////////

// This function sets the visibility of the Streamer.bot status label on the overlay
function SetConnectionStatus(connected) {
	let statusContainer = document.getElementById("statusContainer");
	if (connected) {
		statusContainer.style.background = "#2FB774";
		statusContainer.innerText = "Connected!";
		statusContainer.style.opacity = 1;
		setTimeout(() => {
			statusContainer.style.transition = "all 2s ease";
			statusContainer.style.opacity = 0;
		}, 10);
	}
	else {
		statusContainer.style.background = "#D12025";
		statusContainer.innerText = "Connecting...";
		statusContainer.style.transition = "";
		statusContainer.style.opacity = 1;
	}
}

window.addEventListener("load", () => {
	testWidget("twitch", "xqc");
	testWidget("youtube", "Markiplier");
	testWidget("kick", "adinross");
	testWidget("kofi", "nutty");
	testWidget("streamelements", "streamelements");
});

